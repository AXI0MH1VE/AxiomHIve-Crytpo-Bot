//! Core Types: Deterministic Data Structures
//!
//! All types use Decimal or Rational arithmetic to ensure bitwise determinism.

use rust_decimal::Decimal;
use num_rational::Rational64;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Fixed-point price representation (ensures determinism)
pub type Price = Decimal;
pub type Quantity = Decimal;
pub type Amount = Decimal;

/// Rational number for precise calculations
pub type Rational = Rational64;

/// Symbol identifier (e.g., "BTC/USD")
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Symbol(pub String);

/// Venue identifier (e.g., "binance", "bybit")
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Venue(pub String);

/// Order side
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    Buy,
    Sell,
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderType {
    Limit,
    Market,
    StopLoss,
    TakeProfit,
}

/// Order status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderStatus {
    Pending,
    Submitted,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
}

/// Tick data with deterministic timestamp
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tick {
    pub symbol: Symbol,
    pub venue: Venue,
    pub price: Price,
    pub quantity: Quantity,
    pub timestamp: DateTime<Utc>,
    pub side: Side,
}

/// Order book level
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookLevel {
    pub price: Price,
    pub quantity: Quantity,
}

/// Full order book snapshot (L2/L3)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderBook {
    pub symbol: Symbol,
    pub venue: Venue,
    pub bids: Vec<BookLevel>,
    pub asks: Vec<BookLevel>,
    pub timestamp: DateTime<Utc>,
    pub sequence: u64,
}

/// Trade signal generated by the proposer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeSignal {
    pub symbol: Symbol,
    pub venue: Venue,
    pub side: Side,
    pub order_type: OrderType,
    pub quantity: Quantity,
    pub limit_price: Option<Price>,
    pub stop_price: Option<Price>,
    pub timestamp: DateTime<Utc>,
    /// Contradiction score (higher = more opportunity)
    pub contradiction_score: Decimal,
    /// Entropy count (higher = more disorder)
    pub entropy_count: Decimal,
}

/// Verified trade order (post-verification)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerifiedOrder {
    pub signal: TradeSignal,
    /// C=0 Signature proving the order satisfies all invariants
    pub proof_signature: String,
    /// Mathematical proof (SMT model)
    pub proof: Proof,
    pub verified_at: DateTime<Utc>,
}

/// SMT Solver proof
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub satisfiable: bool,
    pub model: HashMap<String, String>,
    pub axioms_satisfied: Vec<String>,
}

/// Position state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub symbol: Symbol,
    pub venue: Venue,
    pub side: Side,
    pub quantity: Quantity,
    pub entry_price: Price,
    pub current_price: Price,
    pub unrealized_pnl: Amount,
    pub realized_pnl: Amount,
}

/// Portfolio state (Hamiltonian energy model)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Portfolio {
    pub equity: Amount,
    pub positions: Vec<Position>,
    pub total_exposure: Amount,
    pub net_exposure: Amount,
    pub leverage: Decimal,
    /// Hamiltonian energy (risk measure)
    pub energy: Decimal,
    /// Correlation matrix (for diversification check)
    pub correlation_matrix: Vec<Vec<Decimal>>,
}

/// Consistency error metric
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsistencyError {
    pub value: Decimal,
    pub source: String,
    pub timestamp: DateTime<Utc>,
}

/// Entropy count (market disorder)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntropyCount {
    pub value: Decimal,
    pub threshold: Decimal,
    pub regime: MarketRegime,
    pub timestamp: DateTime<Utc>,
}

/// Market regime classification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum MarketRegime {
    HighVolatility,
    LowLiquidity,
    Normal,
    Unprovable, // Stand down mode
}

/// Circuit breaker state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CircuitBreakerState {
    Normal,
    Warning,
    Tripped,
    Halted,
}

/// System health status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemHealth {
    pub consistency_error: ConsistencyError,
    pub entropy_count: EntropyCount,
    pub circuit_breaker: CircuitBreakerState,
    pub hallucination_rate: Decimal,
    pub latency_p50: u64,
    pub latency_p99: u64,
    pub latency_p999: u64,
    pub timestamp: DateTime<Utc>,
}

